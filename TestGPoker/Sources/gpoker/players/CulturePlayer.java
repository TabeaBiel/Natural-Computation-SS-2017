package gpoker.players;

import gpoker.Move;
import gpoker.Player;
import gpoker.gp.Coder;
import gpoker.misc.Xml;
import org.jdom2.Element;

import java.util.AbstractCollection;
import java.util.Collections;
import java.util.List;
import java.util.PriorityQueue;

/**
 * The CodePlayer reads an evolved GProgram from XML and uses it for play.
 *
 * @author Helmut A. Mayer
 * @since May 19, 2016
 *
 */
public class CulturePlayer extends CodePlayer {

	/** Select the player with the currently highest success. */
	private static final int BEST = 0;

	/** Select a player with exponential ranking. */
	private static final int EXP = 1;

	/** The culture. */
	protected PriorityQueue<Player> culture;

	/** The playing master. */
	private Player master;

	/** The mode for master selection. */
	private int selectMode;

	/** Indicates dissection into single master players. */
	private boolean dissect;


	/**
	 * Creates the player via XML.
	 *
	 * @param element an XML player element
	 */
	public CulturePlayer(Element element) {

		super(element);
		culture = new PriorityQueue<>(11, Collections.<Player>reverseOrder());
		List<Element> cfe = element.getChildren("cultureFile");
		for (Element e : cfe)
			Coder.createCulture(e.getText(), culture);
		selectMode = Xml.getProperty(element, "selectMode", EXP);
		dissect = Xml.getProperty(element, "dissect", false);
		if (!dissect)
			master = selectMaster();
	}


	public AbstractCollection<Player> getCulture() {

		return culture;
	}


	/** Indicates dissection of culture player into single master players.
	 *
	 * @return	true, if player is to be dissected into single players
	 */
	public boolean isDissect() {

		return dissect;
	}


	/**
	 * The player's moves cannot be trusted.
	 *
	 * @return false.
	 */
	public boolean isTrusted() {

		return false;
	}


	/**
	 * Adds the win and updates the success of the current master.
	 *
	 * @param	win	the win
	 */
	public void addWin(int win) {

		super.addWin(win);
		master.setSuccess(master.getSuccess() + (long)win);
		culture.add(master);
		master = selectMaster();
//		System.out.println("Selected " + master + " with success " + master.getSuccess());
	}


	/**
	 * Returns the move which is generated by the leading culture player.
	 *
	 * @return the move generated
	 */
	public Move act() {

		program = ((CodePlayer)master).getProgram();							// load the program
		return super.act();
	}


	/** Selects a master according to the selection mode.
	 *
	 * @return		a master of the culture
	 */
	private Player selectMaster() {

		if (selectMode == BEST)
			return culture.poll();
		if (selectMode == EXP)
			return getExpRankMaster();

		return null;  					// should not happen
	}


	/** Selects a master using a selection probability according to exponential ranking. Each rank k is assigned a
	 * probability proportional to exp(-k). For the best player k = 0 and this player gets a selection probability of
	 * roughly 2/3.
	 *
	 * @return	a master
	 */
	private Player getExpRankMaster() {

		double factor = getExpRankFactor();
		double r = Math.random();
		int k = 0;
		double p = 0.0;

		for (Player player : culture) {
			p += Math.exp(-k++) / factor;
//			System.out.println("p = " + p);
			if (r < p) {
				culture.remove(player);
				return player;
			}
		}
		return culture.poll();							// could happen due to numerical problems
	}


	/**
	 * Returns the proportionality factor for exponential ranking so to calculate real probabilities. The factor is based
	 * on a sum of exponentials, which represent a geometric series.
	 *
	 * @return		the factor
	 */
	private double getExpRankFactor() {

		return (1.0 - Math.exp(-culture.size())) / (1.0 - 1.0 / Math.E);
	}


	/**
	 * Returns the string representation of the player.
	 *
	 * @return the player's name
	 */
	public String toString() {

		Player p = master;
		if (p == null)
			p = culture.peek();

		return super.toString() + p + "(" + p.getSuccess() + ")";
	}

}
