package gpoker.players;

import evSOLve.JEvolution.gp.ProgramNode;
import evSOLve.JEvolution.gp.Tree;
import gpoker.*;
import gpoker.gp.Coder;
import gpoker.misc.Xml;
import org.jdom2.Element;

/**
 * The CodePlayer is playing according to a program tree. The program tree is specified in an XML file. The first
 * option is that it is in a {@code codeFile}, which holds a single player with its tree. If this XML tag is not given,
 * then the XML tag {@code cultureFile} is tried, where the XML tag {@code index} points to the tree in the culture file.
 *
 * @author Helmut A. Mayer
 * @since May 19, 2016
 *
 */
public class CodePlayer extends Player {

	/** The program tree. */
	protected Tree program;

	/** The input features. */
	private double[] features;

	/** The next stage. */
	private int prevStage;


	/**
	 * Creates the code player via XML. The code may be in a file with a single GPlayer entry, or in a culture file
	 * with multiple GPlayer entries. In the latter case, an index points to the single code player.
	 *
	 * @param element	an XML player element
	 */
	public CodePlayer(Element element) {

		super(element);
		program = Coder.createProgram(Xml.getProperty(element, "codeFile", null));
		if (program == null)
			Coder.createProgram(Xml.getProperty(element, "codeFile", null), Xml.getProperty(element, "index", 0), this);
		features = new double[10];
	}


	/** Constructs the player with a tree.
	 *
	 * @param tree	a program tree
	 */
	public CodePlayer(Tree tree) {

		super("Tree", 0);
		program = tree;
		features = new double[10];
	}


	/** Returns the program tree.
	 *
	 * @return	the tree
	 */
	public Tree getProgram() {

		return program;
	}


	/** Sets the program tree.
	 *
	 * @param tree	a program tree
	 */
	public void setProgram(Tree tree) {

		program = tree;
	}


	/** Resets the player's hand. */
	public void resetHand() {

		super.resetHand();
		prevStage = Dealer.NEW_HAND;
	}


	/**
	 * The player's moves cannot be trusted.
	 *
	 * @return false.
	 */
	public boolean isTrusted() {

		return false;
	}


	/**
	 * Returns the move which is generated by implementing evolved code.
	 *
	 * @return the move generated
	 */
	public Move act() {

		Dealer dealer = Director.getInstance().getDealer();

		if (dealer.getStage() != prevStage) {
			int handValue = dealer.evaluate(getHand());
			features[2] = (double)handValue / Hand.STRAIGHT_FLUSH;                          // hand value var2
			features[5] = (double)dealer.getStage() / Dealer.RIVER;							// stage value var5
			Card pivot = dealer.getEvaluator().getPivot(getHand(), dealer.getCommunity());
			features[8] = (double)pivot.getRank() / (double)Card.ACE;						// pivot value var8

			if (dealer.getStage() == Dealer.PRE_FLOP) {
				if (!getHand().isSorted())                                                  // hand is hole cards
					getHand().sort();
				features[0] = getHand().getCards().get(0).getRank() / (double)Card.ACE;        // high hole var0
				features[1] = getHand().getCards().get(1).getRank() / (double)Card.ACE;        // low hole var1
				int pos = dealer.getPosition(this);
				if (pos == -1)
					System.out.println("Panic! Illegal position.");
				features[6] = (double)pos;                                                    // pos value var6
				features[7] = (double)Hand.NOT_EVALUATED / (double)Hand.STRAIGHT_FLUSH;        // comm value var7
			} else {
				double communityValue = dealer.getEvaluator().evaluate(dealer.getCommunity());
				features[7] = communityValue / (double)Hand.STRAIGHT_FLUSH;                // comm value var7
			}
		}
		int chips = dealer.getTotalChips();
		features[3] = (double)dealer.getPot() / (double)chips;						// pot value var3

		int callBet = dealer.getCallBet(this);
		if (callBet < 0)
			System.out.println("Panic! Illegal call bet.");
		features[4] = (double)callBet / (double)chips; 								// bet value var4
		chips /= dealer.getPlayers().size();									    // max stack
		features[9] = (double)getChips() / (double)chips;							// stack value var9

		prevStage = dealer.getStage();
//		System.out.println("Stage = " + prevStage + ", " + Arrays.toString(features));
		for (double feature : features)
			ProgramNode.addValue(feature);

		ProgramNode root = (ProgramNode)program.getRoot();
		Move move = ((Move)root.eval()).clone();						// evaluate the program, clone() is important!
		ProgramNode.clearValues();                                        		// reset variable values

		return move;
	}
}
